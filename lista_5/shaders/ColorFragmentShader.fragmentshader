#version 330 core

// Interpolated values from the vertex shaders
in vec3 Position_worldspace;
in vec3 Normal_cameraspace;
in vec3 EyeDirection_cameraspace;
in vec3 LightDirection_cameraspace[10];

in vec3 mat_color;

flat in int iid;
// Ouput data
out vec4 color;


// Values that stay constant for the whole mesh.
uniform sampler2D myTextureSampler;
uniform mat4 MV;
uniform vec3 LightPosition_worldspace;

vec3 calculate_Phong_singular(vec3 PhongDiffuse, vec3 PhongSpecular, vec3 normal, vec3 EyeDirection, vec3 LightColor, float LightPower, vec3 LightPosition) {
	// calculate per light properties
	float distance = length(Position_worldspace - LightPosition);

	// calculate diffuse angle the angle between camera and light
	float cosTheta = clamp(dot(normalize(normal), normalize(LightPosition)), 0, 1);

	// calculate something else for magnum Phong
	vec3 R = reflect(normalize(LightPosition),normalize(normal));
	float cosAlpha = clamp(dot(normalize(EyeDirection), -R), 0, 1);

	vec3 DiffusePartial = PhongDiffuse * vec3(0.0, 1.0, 0.0) * LightPower * cosTheta / (distance*distance);
	vec3 SpecularPartial = PhongSpecular * vec3(0.0, 0.0, 1.0) * LightPower * pow(cosAlpha,5) / (distance*distance);
	
	return DiffusePartial + SpecularPartial; 
}

vec3 calculate_Phong_group(vec3 Material) {
	// load all needed variables

	vec3 MaterialDiffuse = Material;
	vec3 MaterialSpecular = vec3(0.3,0.3,0.3);
	vec3 MaterialAmbient = vec3(0.5,0.5,0.5) * Material;

	// load light properties
	vec3 LightColor = vec3(1.0, 0.0, 0.0);
	float LightPower = 50000.0f;

	vec3 c = MaterialAmbient + calculate_Phong_singular(MaterialDiffuse, MaterialSpecular, Normal_cameraspace, EyeDirection_cameraspace, LightColor, LightPower, LightDirection_cameraspace[0]);

	return c;
}

void main(){
	color = vec4(calculate_Phong_group(vec3(1.0, 1.0, 1.0)), 1.0);
}